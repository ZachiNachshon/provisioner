name: General Availability - Promote RC to PyPI

on:
  workflow_dispatch:
    inputs:
      rc_version:
        type: string
        description: 'Release Candidate version to promote (e.g., 1.2.3-RC.1). Leave empty to auto-select latest RC.'
        required: false
      project_name:
        type: choice
        description: 'Select project to promote to GA'
        options: 
          - 'provisioner'
        required: true

env:
  PYPI_API_TOKEN_PROVISIONER_RUNTIME: ${{ secrets.PROVISIONER_PYPI_API_TOKEN }}
  PYPI_API_TOKEN_PROVISIONER_SHARED: ${{ secrets.PYPI_API_TOKEN_PROVISIONER_SHARED }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  POETRY_VERSION: "1.8.4"
  
jobs:
  promote_rc_to_ga:
    name: Promote RC to General Availability
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python: [ '3.11' ]

    steps:
      - name: Checkout repository code (with submodules)
        uses: actions/checkout@v4
        with:
          submodules: true  # Fetch Git submodules
          token: ${{ secrets.PROVISIONER_PLUGINS_REPO_ACCESS_TOKEN }}

      - name: Setup Environment
        uses: ./.github/actions/setup
        env:
          PYTHON_VERSION: ${{ matrix.python }}
          POETRY_VERSION: ${{ env.POETRY_VERSION }}

      - name: Validate RC Version (if provided)
        run: |
          rc_version="${{ github.event.inputs.rc_version }}"
          if [ -n "$rc_version" ]; then
            if [[ ! "$rc_version" =~ -RC\.[0-9]+$ ]]; then
              echo "Error: Invalid RC version format. Expected format: x.y.z-RC.N"
              exit 1
            fi
            echo "RC version validation passed: $rc_version"
          else
            echo "No RC version provided - will auto-detect latest RC"
          fi

      - name: Check if RC exists in GitHub releases (if specified)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          rc_version="${{ github.event.inputs.rc_version }}"
          project_name="${{ github.event.inputs.project_name }}"
          
          if [ -n "$rc_version" ]; then
            # Check if the RC version exists as a pre-release
            if ! gh release view "v${rc_version}" --repo ${{ github.repository }}; then
              echo "Error: RC version v${rc_version} not found in GitHub releases"
              exit 1
            fi
            
            # Verify it's marked as pre-release
            is_prerelease=$(gh release view "v${rc_version}" --json isPrerelease --jq '.isPrerelease')
            if [[ "$is_prerelease" != "true" ]]; then
              echo "Error: Release v${rc_version} is not marked as pre-release"
              exit 1
            fi
            
            echo "RC version v${rc_version} validated as pre-release"
          else
            echo "No RC version specified - validation will happen during auto-detection"
          fi

      - name: Determine RC Version to Promote
        id: determine_rc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Determining RC version to promote"
          input_rc_version="${{ github.event.inputs.rc_version }}"
          
          if [ -n "$input_rc_version" ]; then
            echo "Using provided RC version: $input_rc_version"
            rc_version="$input_rc_version"
          else
            echo "Auto-detecting latest RC version using GitHub API..."
            # Get all RC tags from GitHub API, sort by version descending, take the first one
            rc_tags=$(gh api repos/:owner/:repo/tags --paginate --jq '.[].name' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+-RC\.[0-9]+$' | sort -V -r)
            
            if [ -z "$rc_tags" ]; then
              echo "Error: No RC versions found in GitHub releases"
              echo "Available tags from GitHub:"
              gh api repos/:owner/:repo/tags --paginate --jq '.[].name' | head -10
              exit 1
            fi
            
            rc_version=$(echo "$rc_tags" | head -1 | sed 's/^v//')
            echo "Auto-detected latest RC version: $rc_version"
          fi
          
          # Generate stable version by removing RC suffix
          stable_version=$(echo "$rc_version" | sed 's/-RC\.[0-9]*$//')
          
          echo "rc_version=$rc_version" >> $GITHUB_OUTPUT
          echo "stable_version=$stable_version" >> $GITHUB_OUTPUT
          echo "Final RC version to promote: $rc_version -> $stable_version"
          echo "::endgroup::"

      - name: Create Stable GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          rc_version="${{ steps.determine_rc.outputs.rc_version }}"
          stable_version="${{ steps.determine_rc.outputs.stable_version }}"
          project_name="${{ github.event.inputs.project_name }}"
          
          echo "::group::Creating stable GitHub release"
          echo "Promoting RC v${rc_version} to stable release v${stable_version}"
          
          # Generate release notes for GA release
          echo "Promoted from Release Candidate v${rc_version}" > ga_release_notes.md
          echo "" >> ga_release_notes.md
          echo "### Changes in this release:" >> ga_release_notes.md
          
          # Get RC release notes and append them
          gh release view "v${rc_version}" --json body --jq '.body' >> ga_release_notes.md || echo "No release notes available from RC" >> ga_release_notes.md
          
          # Use the enhanced publish script to promote RC to GA
          scripts/github_actions/package_deployer.sh upload \
            --upload-action promote-rc \
            --source-tag "v${rc_version}" \
            --release-tag "v${stable_version}" \
            --release-title "Release v${stable_version}" \
            --release-notes-file "ga_release_notes.md" \
            -y
          
          # Mark the new release as latest
          gh release edit "v${stable_version}" --latest
          
          echo "Successfully created stable release v${stable_version}"
          echo "::endgroup::"

      - name: Upload Stable Release to PyPI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          stable_version="${{ steps.determine_rc.outputs.stable_version }}"
          project_name="${{ github.event.inputs.project_name }}"
          
          echo "::group::Uploading stable release to PyPI"
          echo "Uploading v${stable_version} to PyPI"
          
          # Map PyPI API token based on project
          case "$project_name" in
            provisioner)
              export PYPI_API_TOKEN="${{ env.PYPI_API_TOKEN_PROVISIONER_RUNTIME }}"
              ;;
            *)
              echo "Unknown project_name: $project_name"
              exit 1
              ;;
          esac
          
          # Use the enhanced publish script to upload GA release to PyPI
          scripts/github_actions/package_deployer.sh upload \
            --upload-action upload-to-pypi \
            --source-tag "v${stable_version}" \
            -y
          
          echo "Successfully uploaded v${stable_version} to PyPI"
          echo "::endgroup::"

      - name: Update Project Versions for Next Development Cycle
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Updating project versions for next development cycle"
          project_name="${{ github.event.inputs.project_name }}"
          stable_version="${{ steps.determine_rc.outputs.stable_version }}"
          
          # Calculate next development version (patch bump)
          IFS='.' read -r major minor patch <<< "${stable_version}"
          next_version="${major}.${minor}.$((patch + 1))"
          
          echo "Released version: ${stable_version}"
          echo "Next development version: ${next_version}"
          
          # Update project versions to next development version
          cd ${project_name}
          poetry version ${next_version}
          
                      # Update manifest.json if it exists
            if [ -f "resources/manifest.json" ]; then
              python3 -c "
import json
with open('resources/manifest.json', 'r') as f:
    data = json.load(f)
data['version'] = '${next_version}'
with open('resources/manifest.json', 'w') as f:
    json.dump(data, f, indent=2)
"
            fi
            cd ..
            
            # Update provisioner_shared version to next development version
            cd provisioner_shared
            poetry version ${next_version}
            
            # Update manifest.json if it exists
            if [ -f "resources/manifest.json" ]; then
              python3 -c "
import json
with open('resources/manifest.json', 'r') as f:
    data = json.load(f)
data['version'] = '${next_version}'
with open('resources/manifest.json', 'w') as f:
    json.dump(data, f, indent=2)
"
            fi
          cd ..
          
          # Prepare git for commit
          git config --global user.email "zachi.nachshon@gmail.com"
          git config --global user.name "ZachiNachshon"
          
          # Create PR with version updates
          cd provisioner_shared
          git add resources/manifest.json pyproject.toml || true
          cd ..

          cd ${project_name}
          git add resources/manifest.json pyproject.toml || true
          cd ..

          branch_name=post-release-${project_name}-v${stable_version}-next-${next_version}
          git commit -m "Post-release: bump ${project_name} to next development version ${next_version}" || echo "No changes to commit"
          git checkout -b ${branch_name}
          git push --set-upstream origin ${branch_name}
          
          gh pr create --title "[skip ci] Post-release: bump ${project_name} to v${next_version}" \
              --body "Post-release version bump after promoting v${stable_version} to General Availability.

          **Released:** v${stable_version} (promoted from RC, published to GitHub + PyPI)  
          **Next Development:** v${next_version}
          
          This follows the 'build once, promote many' approach - artifacts were not rebuilt." \
              --base master --head ${branch_name} \
              --label "auto pr" \
              --label "post-release"
              
          echo "::endgroup::" 